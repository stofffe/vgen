// THIS FILE IS GENERATED BY VGEN
// DO NOT EDIT
package main

import (
	"fmt"
)

type AddressVgen struct {
	Street *string `json:"street"`
	Number *int    `json:"number"`
}

func (t AddressVgen) Validate() map[string][]string {
	errs := make(map[string][]string)
	if t.Street != nil {
		_Street := *t.Street
		{
			path := fmt.Sprintf("street")
			if !(len(_Street) > 0) {
				errs[path] = append(errs[path], fmt.Sprintf("can not be empty"))
			}
		}
	} else {
		errs["street"] = append(errs["street"], fmt.Sprintf("required"))
	}
	if t.Number != nil {
		_Number := *t.Number
		{
			path := fmt.Sprintf("number")
			if !(_Number < 5) {
				errs[path] = append(errs[path], fmt.Sprintf("must be < 5"))
			}
		}
	} else {
		errs["number"] = append(errs["number"], fmt.Sprintf("required"))
	}
	return errs
}
func (t AddressVgen) Convert() Address {
	var res Address
	if t.Street != nil {
		_Street := *t.Street
		res.Street = _Street
	}
	if t.Number != nil {
		_Number := *t.Number
		res.Number = _Number
	}
	return res
}
func (t AddressVgen) ValidatedConvert() (Address, *map[string][]string) {
	errs := t.Validate()
	if len(errs) > 0 {
		return Address{}, &errs
	}
	return t.Convert(), nil
}

type PersonVgen struct {
	Name       *string          `json:"name"`
	Address1   *Address         `json:"address1"`
	Address2   *AddressVgen     `json:"address2"`
	Addresses  *[]Address       `json:"addresses"`
	Addresses2 *[][]AddressVgen `json:"addresses2"`
}

func (t PersonVgen) Validate() map[string][]string {
	errs := make(map[string][]string)
	if t.Name != nil {
		_Name := *t.Name
		{
			path := fmt.Sprintf("name")
			if !(len(_Name) > 0) {
				errs[path] = append(errs[path], fmt.Sprintf("can not be empty"))
			}
			if !(len(_Name) < 20) {
				errs[path] = append(errs[path], fmt.Sprintf("len must be < 20"))
			}
		}
	} else {
		errs["name"] = append(errs["name"], fmt.Sprintf("required"))
	}
	if t.Address1 != nil {
		_Address1 := *t.Address1
		{
			path := fmt.Sprintf("address1")
			if err := valAddr(_Address1); err != nil {
				errs[path] = append(errs[path], err.Error())
			}
		}
	}
	if t.Address2 != nil {
		_Address2 := *t.Address2
		{
			path := fmt.Sprintf("address2")
			struct_errs := _Address2.Validate()
			for nested_path, err_list := range struct_errs {
				for _, err := range err_list {
					errs[path+"."+nested_path] = append(errs[path+"."+nested_path], err)
				}
			}
			_Address2 := _Address2.Convert()
			if err := valAddr(_Address2); err != nil {
				errs[path] = append(errs[path], err.Error())
			}
		}
	} else {
		errs["address2"] = append(errs["address2"], fmt.Sprintf("required"))
	}
	if t.Addresses != nil {
	} else {
		errs["addresses"] = append(errs["addresses"], fmt.Sprintf("required"))
	}
	if t.Addresses2 != nil {
		_Addresses2 := *t.Addresses2
		{
			for i0, _Addresses2 := range _Addresses2 {
				for i1, _Addresses2 := range _Addresses2 {
					path := fmt.Sprintf("addresses2[%d][%d]", i0, i1)
					struct_errs := _Addresses2.Validate()
					for nested_path, err_list := range struct_errs {
						for _, err := range err_list {
							errs[path+"."+nested_path] = append(errs[path+"."+nested_path], err)
						}
					}
					_Addresses2 := _Addresses2.Convert()
					if err := valAddr(_Addresses2); err != nil {
						errs[path] = append(errs[path], err.Error())
					}
				}
			}
		}
	} else {
		errs["addresses2"] = append(errs["addresses2"], fmt.Sprintf("required"))
	}
	return errs
}
func (t PersonVgen) Convert() Person {
	var res Person
	if t.Name != nil {
		_Name := *t.Name
		res.Name = _Name
	}
	if t.Address1 != nil {
		_Address1 := *t.Address1
		res.Address1 = _Address1
	}
	if t.Address2 != nil {
		_Address2 := *t.Address2
		res.Address2 = _Address2.Convert()
	}
	if t.Addresses != nil {
		_Addresses := *t.Addresses
		res.Addresses = _Addresses
	}
	if t.Addresses2 != nil {
		_Addresses2 := *t.Addresses2
		res.Addresses2 = make([][]Address, len(_Addresses2))
		for i0, _Addresses2 := range _Addresses2 {
			for i1, _Addresses2 := range _Addresses2 {
				res.Addresses2[i0][i1] = _Addresses2.Convert()
			}
		}
	}
	return res
}
func (t PersonVgen) ValidatedConvert() (Person, *map[string][]string) {
	errs := t.Validate()
	if len(errs) > 0 {
		return Person{}, &errs
	}
	return t.Convert(), nil
}
