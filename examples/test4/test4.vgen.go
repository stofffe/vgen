// THIS FILE IS GENERATED BY VGEN
// DO NOT EDIT

package main

import (
	"encoding/json"

	"fmt"
)

type AddressVgen struct {
	Street *string
	Number *int
}

func (t AddressVgen) Validate() (Address, error) {
	// TODO add output formatting here
	address, errs := t.innerValidation()
	if len(errs) > 0 {
		j, _ := json.Marshal(errs)
		return Address{}, fmt.Errorf("%s", j)
	}
	return address, nil
}

func (t AddressVgen) innerValidation() (Address, map[string][]string) {
	res := Address{}
	errs := make(map[string][]string)

	if t.Street != nil {

		street := *t.Street

		if !(len(street) > 0) {
			errs["street"] = append(errs["street"], fmt.Sprintf(`can not be empty`))
		}

		res.Street = street
	} else {
		errs["street"] = append(errs["street"], fmt.Sprintf("required"))
	}

	if t.Number != nil {

		number := *t.Number

		if !(number >= 0) {
			errs["number"] = append(errs["number"], fmt.Sprintf(`must be greater than or equal to 0`))
		}

		res.Number = number
	} else {
		errs["number"] = append(errs["number"], fmt.Sprintf("required"))
	}

	if len(errs) > 0 {
		return Address{}, errs
	}

	return res, nil
}

type PersonVgen struct {
	Address   *AddressVgen
	Addresses *[]Address
	Strings   *[]string
}

func (t PersonVgen) Validate() (Person, error) {
	// TODO add output formatting here
	person, errs := t.innerValidation()
	if len(errs) > 0 {
		j, _ := json.Marshal(errs)
		return Person{}, fmt.Errorf("%s", j)
	}
	return person, nil
}

func (t PersonVgen) innerValidation() (Person, map[string][]string) {
	res := Person{}
	errs := make(map[string][]string)

	if t.Address != nil {

		address, err := t.Address.innerValidation()
		if err != nil {
			for k, v := range err {
				errs["address."+k] = append(errs["address."+k], v...)
			}
		} else {

		}

		res.Address = address
	} else {
		errs["address"] = append(errs["address"], fmt.Sprintf("required"))
	}

	if t.Addresses != nil {

		addresses := *t.Addresses

		if !(len(addresses) > 0) {
			errs["addresses"] = append(errs["addresses"], fmt.Sprintf(`len must be greater than 0`))
		}

		for i, addresses := range addresses {
			index := fmt.Sprintf("[%d]", i)

			if err := abc(addresses); err != nil {
				errs["addresses"+index] = append(errs["addresses"+index], fmt.Sprintf(`%v`, err))
			}

		}

		res.Addresses = addresses
	} else {
		errs["addresses"] = append(errs["addresses"], fmt.Sprintf("required"))
	}

	if t.Strings != nil {

		strings := *t.Strings

		if !(len(strings) > 0) {
			errs["strings"] = append(errs["strings"], fmt.Sprintf(`len must be greater than 0`))
		}

		for i, strings := range strings {
			index := fmt.Sprintf("[%d]", i)

			if !(len(strings) > 0) {
				errs["strings"+index] = append(errs["strings"+index], fmt.Sprintf(`can not be empty`))
			}

		}

		res.Strings = strings
	} else {
		errs["strings"] = append(errs["strings"], fmt.Sprintf("required"))
	}

	if len(errs) > 0 {
		return Person{}, errs
	}

	return res, nil
}
