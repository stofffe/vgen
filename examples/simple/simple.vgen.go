// THIS FILE IS GENERATED BY VGEN
// DO NOT EDIT
package main
import (
	"encoding/json"
	"fmt"
)
type EmailVgen struct {
	Title  *string
	Text   *string
	Sender *string
}
func (t EmailVgen) Validate() (Email, error) {
	email, errs := t.InnerValidation()
	if len(errs) > 0 {
		j, _ := json.Marshal(errs)
		return Email{}, fmt.Errorf("%s", j)
	}
	return email, nil
}
func (t EmailVgen) InnerValidation() (Email, map[string][]string) {
	res := Email{}
	errs := make(map[string][]string)
	if t.Title != nil {
		title := *t.Title
		{
			if !(len(title) > 0) {
				errs[fmt.Sprintf("title")] = append(errs[fmt.Sprintf("title")], fmt.Sprintf("can not be empty"))
			}
			if !(len(title) < 50) {
				errs[fmt.Sprintf("title")] = append(errs[fmt.Sprintf("title")], fmt.Sprintf("len must be < 50"))
			}
			_ = title
		}
	} else {
		errs["title"] = append(errs["title"], fmt.Sprintf("required"))
	}
	if t.Text != nil {
		text := *t.Text
		{
			if !(len(text) > 0) {
				errs[fmt.Sprintf("text")] = append(errs[fmt.Sprintf("text")], fmt.Sprintf("can not be empty"))
			}
			if !(len(text) > 200) {
				errs[fmt.Sprintf("text")] = append(errs[fmt.Sprintf("text")], fmt.Sprintf("len must be > 200"))
			}
			_ = text
		}
	} else {
		errs["text"] = append(errs["text"], fmt.Sprintf("required"))
	}
	if t.Sender != nil {
		sender := *t.Sender
		{
			if !(len(sender) > 0) {
				errs[fmt.Sprintf("sender")] = append(errs[fmt.Sprintf("sender")], fmt.Sprintf("can not be empty"))
			}
			if !(len(sender) < 20) {
				errs[fmt.Sprintf("sender")] = append(errs[fmt.Sprintf("sender")], fmt.Sprintf("len must be < 20"))
			}
			_ = sender
		}
	} else {
		errs["sender"] = append(errs["sender"], fmt.Sprintf("required"))
	}
	if len(errs) > 0 {
		return Email{}, errs
	}
	return res, nil
}
