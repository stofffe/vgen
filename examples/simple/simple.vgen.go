//
// THIS FILE IS GENERATED BY VGEN
// DO NOT EDIT
//
package main
import (
	"fmt"
)
type EmailVgen struct {
	Title *string `json:"title"`
	Text *string `json:"text"`
	Sender *string `json:"sender"`
}
func (t EmailVgen) Validate() map[string][]string {
	errs := make(map[string][]string)
	if t.Title != nil {
		_Title := *t.Title
		{
			path := fmt.Sprintf("title")
			if !(len(_Title) > 0) {
				errs[path] = append(errs[path], fmt.Sprintf("can not be empty"))
			}
			if !(len(_Title) < 50) {
				errs[path] = append(errs[path], fmt.Sprintf("len must be < 50"))
			}
		}
	} else {
		errs["title"] = append(errs["title"], fmt.Sprintf("required"))
	}
	if t.Text != nil {
		_Text := *t.Text
		{
			path := fmt.Sprintf("text")
			if !(len(_Text) > 0) {
				errs[path] = append(errs[path], fmt.Sprintf("can not be empty"))
			}
			if !(len(_Text) > 200) {
				errs[path] = append(errs[path], fmt.Sprintf("len must be > 200"))
			}
		}
	} else {
		errs["text"] = append(errs["text"], fmt.Sprintf("required"))
	}
	if t.Sender != nil {
		_Sender := *t.Sender
		{
			path := fmt.Sprintf("sender")
			if !(len(_Sender) > 0) {
				errs[path] = append(errs[path], fmt.Sprintf("can not be empty"))
			}
			if !(len(_Sender) < 20) {
				errs[path] = append(errs[path], fmt.Sprintf("len must be < 20"))
			}
		}
	} else {
		errs["sender"] = append(errs["sender"], fmt.Sprintf("required"))
	}
	return errs
}
func (t EmailVgen) Convert() Email {
	var res Email
	if t.Title != nil {
		_Title := *t.Title
		res.Title = _Title
	}
	if t.Text != nil {
		_Text := *t.Text
		res.Text = _Text
	}
	if t.Sender != nil {
		_Sender := *t.Sender
		res.Sender = _Sender
	}
	return res
}
func (t EmailVgen) ValidatedConvert() (Email, *map[string][]string) {
	errs := t.Validate()
	if len(errs) > 0 {
		return Email{}, &errs
	}
	return t.Convert(), nil
}
