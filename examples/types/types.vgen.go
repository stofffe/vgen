// THIS FILE IS GENERATED BY VGEN
// DO NOT EDIT
package main

import (
	"encoding/json"
	"fmt"
)

type AddressVgen struct {
	Street *string `json:"street"`
	Number *int    `json:"number"`
}

func (t AddressVgen) Validate() (Address, error) {
	errs := t.InnerValidation()
	if len(errs) > 0 {
		j, _ := json.Marshal(errs)
		return Address{}, fmt.Errorf("%s", j)
	}
	return Address{}, nil
}
func (t AddressVgen) InnerValidation() map[string][]string {
	errs := make(map[string][]string)
	if t.Street != nil {
		_Street := *t.Street
		{
			if !(len(_Street) > 0) {
				errs[fmt.Sprintf("street")] = append(errs[fmt.Sprintf("street")], fmt.Sprintf("can not be empty"))
			}
			_ = _Street
		}
	} else {
		errs["street"] = append(errs["street"], fmt.Sprintf("required"))
	}
	if t.Number != nil {
		_Number := *t.Number
		{
			if !(_Number < 5) {
				errs[fmt.Sprintf("number")] = append(errs[fmt.Sprintf("number")], fmt.Sprintf("must be < 5"))
			}
			_ = _Number
		}
	} else {
		errs["number"] = append(errs["number"], fmt.Sprintf("required"))
	}
	return errs
}
func (t AddressVgen) Convert() Address {
	var res Address
	if t.Street != nil {
		res.Street = *t.Street
	}
	if t.Number != nil {
		res.Number = *t.Number
	}
	return Address{}
}
func AddressFromJson(bytes []byte) (Address, error) {
	var v AddressVgen
	err := json.Unmarshal(bytes, &v)
	if err != nil {
		return Address{}, err
	}
	r, err := v.Validate()
	if err != nil {
		return Address{}, err
	}
	return r, nil
}

type PersonVgen struct {
	Name     *string      `json:"name"`
	Address1 *Address     `json:"address1"`
	Address2 *AddressVgen `json:"address2"`
}

func (t PersonVgen) Validate() (Person, error) {
	errs := t.InnerValidation()
	if len(errs) > 0 {
		j, _ := json.Marshal(errs)
		return Person{}, fmt.Errorf("%s", j)
	}
	return Person{}, nil
}
func (t PersonVgen) InnerValidation() map[string][]string {
	errs := make(map[string][]string)
	if t.Name != nil {
		_Name := *t.Name
		{
			if !(len(_Name) > 0) {
				errs[fmt.Sprintf("name")] = append(errs[fmt.Sprintf("name")], fmt.Sprintf("can not be empty"))
			}
			if !(len(_Name) < 20) {
				errs[fmt.Sprintf("name")] = append(errs[fmt.Sprintf("name")], fmt.Sprintf("len must be < 20"))
			}
			_ = _Name
		}
	} else {
		errs["name"] = append(errs["name"], fmt.Sprintf("required"))
	}
	if t.Address1 != nil {
		_Address1 := *t.Address1
		{
			if err := abc(_Address1); err != nil {
				errs[fmt.Sprintf("address1")] = append(errs[fmt.Sprintf("address1")], err.Error())
			}
			_ = _Address1
		}
	}
	if t.Address2 != nil {
		_Address2 := *t.Address2
		{
			struct_errs := _Address2.InnerValidation()
			for path, err_list := range struct_errs {
				for _, err := range err_list {
					errs[fmt.Sprintf("address2")+"."+path] = append(errs[fmt.Sprintf("address2")+"."+path], err)
				}
			}
			_Address2 := _Address2.Convert()
			if err := abc(_Address2); err != nil {
				errs[fmt.Sprintf("address2")] = append(errs[fmt.Sprintf("address2")], err.Error())
			}
		}
	} else {
		errs["address2"] = append(errs["address2"], fmt.Sprintf("required"))
	}
	return errs
}
func (t PersonVgen) Convert() Person {
	var res Person
	if t.Name != nil {
		res.Name = *t.Name
	}
	if t.Address1 != nil {
		res.Address1 = *t.Address1
	}
	if t.Address2 != nil {
		res.Address2 = t.Address2.Convert()
	}
	return Person{}
}
func PersonFromJson(bytes []byte) (Person, error) {
	var v PersonVgen
	err := json.Unmarshal(bytes, &v)
	if err != nil {
		return Person{}, err
	}
	r, err := v.Validate()
	if err != nil {
		return Person{}, err
	}
	return r, nil
}
