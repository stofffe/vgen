//
// THIS FILE IS GENERATED BY VGEN
// DO NOT EDIT
//
package main
import (
	"fmt"
)
type NameVgen struct {
	value *string
}
func (t NameVgen) Validate() map[string][]string {
	errs := make(map[string][]string)
	if t.value != nil {
	} else {
		errs["value"] = append(errs["value"], fmt.Sprintf("required"))
	}
	return errs
}
func (t NameVgen) Convert() Name {
	var res Name
	if t.value != nil {
		_value := *t.value
		res.value = _value
	}
	return res
}
func (t NameVgen) ValidatedConvert() (Name, *map[string][]string) {
	errs := t.Validate()
	if len(errs) > 0 {
		return Name{}, &errs
	}
	return t.Convert(), nil
}
type PersonVgen struct {
	A *string
	B *[]string
	C *[][]string
	D *NameVgen
	E *[]Name
	F *[][]NameVgen
}
func (t PersonVgen) Validate() map[string][]string {
	errs := make(map[string][]string)
	if t.A != nil {
		_A := *t.A
		{
			path := fmt.Sprintf("A")
			if !(len(_A) > 0) {
				errs[path] = append(errs[path], fmt.Sprintf("can not be empty"))
			}
		}
	} else {
		errs["A"] = append(errs["A"], fmt.Sprintf("required"))
	}
	if t.B != nil {
	}
	if t.C != nil {
	}
	if t.D != nil {
		_D := *t.D
		{
			path := fmt.Sprintf("D")
			struct_errs := _D.Validate()
			for nested_path, err_list := range struct_errs {
				for _, err := range err_list {
					errs[path+"."+nested_path] = append(errs[path+"."+nested_path], err)
				}
			}
		}
	} else {
		errs["D"] = append(errs["D"], fmt.Sprintf("required"))
	}
	if t.E != nil {
	}
	if t.F != nil {
		_F := *t.F
		{
			for i0, _F := range _F {
				for i1, _F := range _F {
					path := fmt.Sprintf("F[%d][%d]", i0, i1)
					struct_errs := _F.Validate()
					for nested_path, err_list := range struct_errs {
						for _, err := range err_list {
							errs[path+"."+nested_path] = append(errs[path+"."+nested_path], err)
						}
					}
				}
			}
		}
	}
	return errs
}
func (t PersonVgen) Convert() Person {
	var res Person
	if t.A != nil {
		_A := *t.A
		res.A = _A
	}
	if t.B != nil {
		_B := *t.B
		res.B = _B
	}
	if t.C != nil {
		_C := *t.C
		res.C = _C
	}
	if t.D != nil {
		_D := *t.D
		res.D = _D.Convert()
	}
	if t.E != nil {
		_E := *t.E
		res.E = _E
	}
	if t.F != nil {
		_F := *t.F
		res.F = make([][]Name, len(_F))
		for i0, _F := range _F {
			res.F[i0] = make([]Name, len(_F))
			for i1, _F := range _F {
				res.F[i0][i1] = _F.Convert()
			}
		}
	}
	return res
}
func (t PersonVgen) ValidatedConvert() (Person, *map[string][]string) {
	errs := t.Validate()
	if len(errs) > 0 {
		return Person{}, &errs
	}
	return t.Convert(), nil
}
