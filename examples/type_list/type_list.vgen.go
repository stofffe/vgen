// THIS FILE IS GENERATED BY VGEN
// DO NOT EDIT
package main
import (
	"fmt"
)
type NameVgen struct {
	value *string
}
func (t NameVgen) ValidatedConvert() (Name, *map[string][]string) {
	errs := t.Validate()
	if len(errs) > 0 {
		return Name{}, &errs
	}
	return t.Convert(), nil
}
func (t NameVgen) Validate() map[string][]string {
	errs := make(map[string][]string)
	if t.value != nil {
		_value := *t.value
		{
			_ = _value
		}
	} else {
		errs["value"] = append(errs["value"], fmt.Sprintf("required"))
	}
	return errs
}
func (t NameVgen) Convert() Name {
	var res Name
	if t.value != nil {
		_value := *t.value
		res.value = _value
	}
	return res
}
type PersonVgen struct {
	A *string
	B *[]string
	C *[][]string
	D *NameVgen
	E *[]NameVgen
	F *[][]NameVgen
}
func (t PersonVgen) ValidatedConvert() (Person, *map[string][]string) {
	errs := t.Validate()
	if len(errs) > 0 {
		return Person{}, &errs
	}
	return t.Convert(), nil
}
func (t PersonVgen) Validate() map[string][]string {
	errs := make(map[string][]string)
	if t.A != nil {
		_A := *t.A
		{
			_ = _A
		}
	} else {
		errs["A"] = append(errs["A"], fmt.Sprintf("required"))
	}
	if t.B != nil {
		_B := *t.B
		{
			for i0, _B := range _B {
				_ = _B
				_ = i0
			}
		}
	}
	if t.C != nil {
		_C := *t.C
		{
			for i0, _C := range _C {
				for i1, _C := range _C {
					_ = _C
					_ = i1
				}
				_ = i0
			}
		}
	}
	if t.D != nil {
		_D := *t.D
		{
			struct_errs := _D.Validate()
			for path, err_list := range struct_errs {
				for _, err := range err_list {
					errs[fmt.Sprintf("D")+"."+path] = append(errs[fmt.Sprintf("D")+"."+path], err)
				}
			}
			_D := _D.Convert()
			_ = _D
		}
	} else {
		errs["D"] = append(errs["D"], fmt.Sprintf("required"))
	}
	if t.E != nil {
		_E := *t.E
		{
			for i0, _E := range _E {
				struct_errs := _E.Validate()
				for path, err_list := range struct_errs {
					for _, err := range err_list {
						errs[fmt.Sprintf("E[%d]", i0)+"."+path] = append(errs[fmt.Sprintf("E[%d]", i0)+"."+path], err)
					}
				}
				_E := _E.Convert()
				_ = _E
				_ = i0
			}
		}
	}
	if t.F != nil {
		_F := *t.F
		{
			for i0, _F := range _F {
				for i1, _F := range _F {
					struct_errs := _F.Validate()
					for path, err_list := range struct_errs {
						for _, err := range err_list {
							errs[fmt.Sprintf("F[%d][%d]", i0, i1)+"."+path] = append(errs[fmt.Sprintf("F[%d][%d]", i0, i1)+"."+path], err)
						}
					}
					_F := _F.Convert()
					_ = _F
					_ = i1
				}
				_ = i0
			}
		}
	}
	return errs
}
func (t PersonVgen) Convert() Person {
	var res Person
	if t.A != nil {
		_A := *t.A
		res.A = _A
	}
	if t.B != nil {
		_B := *t.B
		res.B = make([]string, len(_B))
		for i0, _B := range _B {
			res.B[i0] = _B
		}
	}
	if t.C != nil {
		_C := *t.C
		res.C = make([][]string, len(_C))
		for i0, _C := range _C {
			res.C[i0] = make([]string, len(_C))
			for i1, _C := range _C {
				res.C[i0][i1] = _C
			}
		}
	}
	if t.D != nil {
		_D := *t.D
		res.D = _D.Convert()
	}
	if t.E != nil {
		_E := *t.E
		res.E = make([]Name, len(_E))
		for i0, _E := range _E {
			res.E[i0] = _E.Convert()
		}
	}
	if t.F != nil {
		_F := *t.F
		res.F = make([][]Name, len(_F))
		for i0, _F := range _F {
			res.F[i0] = make([]Name, len(_F))
			for i1, _F := range _F {
				res.F[i0][i1] = _F.Convert()
			}
		}
	}
	return res
}
