package main

import (
	"bytes"
	_ "embed"
	"fmt"
	"go/format"
	"strings"
	"text/template"
)

//go:embed template.tmpl
var template_str string

//go:embed rules.tmpl
var rules_str string

var tmpl *template.Template

func generateFile(info ParseInfo) ([]byte, error) {
	var buffer bytes.Buffer

	// init global tmpl and parse template
	var err error
	tmpl, err = template.New("template").Funcs(template.FuncMap{
		"iterate": func(count int) []int {
			var i int
			var Items []int
			for i = 0; i < count; i++ {
				Items = append(Items, i)
			}
			return Items
		},
		"call": func(name string, data interface{}) (string, error) {
			var buffer bytes.Buffer
			err := tmpl.ExecuteTemplate(&buffer, name, data)
			if err != nil {
				return "", err
			}
			return buffer.String(), nil
		},
		"add": func(a, b int) int {
			return a + b
		},
		"sub": func(a, b int) int {
			return a - b
		},
	}).Parse(template_str + rules_str)
	if err != nil {
		return []byte{}, fmt.Errorf("could not parse template file: %v", err)
	}

	// package
	err = tmpl.ExecuteTemplate(&buffer, "package", info)
	if err != nil {
		return []byte{}, fmt.Errorf("could not execute package template: %v", err)
	}

	// structs
	for _, struct_type := range info.StructTypes {
		// type
		err := tmpl.ExecuteTemplate(&buffer, "struct-type", struct_type)
		if err != nil {
			return []byte{}, fmt.Errorf("could not execute struct-type template: %v", err)
		}

		// validation
		err = tmpl.ExecuteTemplate(&buffer, "struct-validation", struct_type)
		if err != nil {
			return []byte{}, fmt.Errorf("could not execute struct-validation: %v", err)
		}

		// conversion
		err = tmpl.ExecuteTemplate(&buffer, "struct-convert", struct_type)
		if err != nil {
			return []byte{}, fmt.Errorf("could not execute struct-convert: %v", err)
		}

		// validation and conversion
		err = tmpl.ExecuteTemplate(&buffer, "struct-validation-convert", struct_type)
		if err != nil {
			return []byte{}, fmt.Errorf("could not execute struct-convert: %v", err)
		}
	}

	// json decoding
	// err = tmpl.ExecuteTemplate(&buffer, "json-decoding", struct_type)
	// if err != nil {
	// 	return []byte{}, fmt.Errorf("could not execute json-decoding: %v", err)
	// }

	// }

	// debug
	// return buffer.Bytes(), nil
	if DEBUG {
		return buffer.Bytes(), nil
	}

	// fmt
	bytes, err := format.Source(buffer.Bytes())
	if err != nil {
		return []byte{}, fmt.Errorf("could not format generated file: %v", err)
	}

	// Remove all empty lines
	// TODO slow
	bytes = []byte(strings.ReplaceAll(string(bytes), "\n\n", "\n"))

	return bytes, nil

}

// var tmpl *template.Template

// func templateToString(name string, data any) (string, error) {
// 	var buffer bytes.Buffer
// 	err := tmpl.ExecuteTemplate(&buffer, name, data)
// 	if err != nil {
// 		return "", err
// 	}
// 	return buffer.String(), nil
// }
//
// func (f PrimField) ValidationCode() (string, error) {
// 	return templateToString("prim-field-validation", f)
// }
// func (f TypeField) ValidationCode() (string, error) {
// 	return templateToString("type-field-validation", f)
// }
// func (f ListField) ValidationCode() (string, error) {
// 	return templateToString("list-field-validation", f)
// }
// func (r Rule) Code() (string, error) {
// 	return templateToString(r.rule, r)
// }
//
// func (f PrimField) ConvertCode() (string, error) {
// 	return templateToString("prim-field-convert", f)
// }
// func (f TypeField) ConvertCode() (string, error) {
// 	return templateToString("type-field-convert", f)
// }
// func (f ListField) ConvertCode() (string, error) {
// 	if _, ok := f.inner.(ListField); ok {
// 		return templateToString("list-field-convert-outer", f)
// 	}
// 	return templateToString("list-field-convert-inner", f)
// }
// // package
// _, err := buffer.WriteString(fmt.Sprintf("package %s\n", info.Package))
//
// // structs
// for _, struct_type := range info.StructTypes {
//
// 	// struct type
// 	buffer.WriteString(fmt.Sprintf("type %sVgen struct {\n", struct_type.name))
// 	for _, field := range struct_type.fields {
// 		buffer.WriteString(fmt.Sprintf("%s *%s %s\n", field.name, field.field.ValidationTyp(), field.tags))
// 	}
// 	buffer.WriteString("}\n")
//
// 	// struct validation
// 	buffer.WriteString(fmt.Sprintf("func (t %sVgen) Validate() map[string][]string {\n"))
// 	buffer.WriteString(fmt.Sprintf("errs := make(map[string][]string)\n"))
// 	for _, field := range struct_type.fields {
// 		buffer.WriteString(fmt.Sprintf("if t.%s != nil {\n", struct_type.name))
// 		buffer.WriteString(fmt.Sprintf("_%s := *t.%s\n", struct_type.name, struct_type.name))
//
// 	}
// }
// const template_combined = template_package + template_struct_type + template_struct_validation
//
// const template_package = `
// {{ define "package" }}
// // THIS FILE IS GENERATED BY VGEN
// // DO NOT EDIT
// package {{ .Package }}
// import (
//     {{ range .Imports }}
//         "{{ . }}"
//     {{ end }}
// )
// {{ end }}
// `
//
// const template_struct_type = `
// {{ define "struct-type" }}
// type {{ .Name }}Vgen struct {
//     {{- range .Fields }}
//         {{ .Name }} *{{ .Field.ValidationTyp -}} {{ .Tags }}
//     {{ end }}
// }
// {{ end }}
// `
//
// const template_struct_validation = `
// {{ define "struct-validation" }}
// func (t {{ .Name }}Vgen) ValidatedConvert() ({{ .Name }}, *map[string][]string) {
//     errs :=  t.Validate()
//     if len(errs) > 0 {
//         return {{ .Name }}{}, &errs
//     }
//     return t.Convert(), nil
// }
//
// func (t {{ .Name }}Vgen) Validate() map[string][]string {
//     errs := make(map[string][]string)
//
//     {{ range .Fields }}
//         if t.{{ .Name }} != nil {
//             _{{ .Name }} := *t.{{ .Name }}
//             {
//                 {{ .Field.ValidationCode }}
//             }
//         } {{ if .Required }} else {
//                 errs["{{ .Alias }}"] = append(errs["{{ .Alias }}"], fmt.Sprintf("required"))
//         } {{ end }}
//     {{ end }}
//
//     return errs
// }
// {{ end }}
// `

//
// {{ define "prim-field-validation"}}
// {{ range .Rules }}
//     {{ .Code }}
// {{ else }}
//     _ = _{{ .Name }}
// {{ end }}
// {{ end }}
//
// {{ define "list-field-validation"}}
// {{ range .Rules }}
//     {{ .Code }}
// {{ end }}
// for i{{ .Depth }}, _{{ .Name }} := range _{{ .Name }} {
//     {{ .Inner.ValidationCode }}
//     // TODO remove 1 _ = i{{ .Depth }}
// }
// {{ end }}
//
// {{ define "type-field-validation"}}
// {{ if .Include }}
//     struct_errs := _{{ .Name }}.Validate()
//     for path, err_list := range struct_errs {
//         for _, err := range err_list {
//             errs[{{ .Path }} + "." + path] = append(errs[{{ .Path }} + "." + path], err)
//         }
//     }
// {{ end }}
// {{ if .Rules }}
//     _{{ .Name }} := _{{ .Name }}.Convert()
//     {{ range .Rules }}
//         // RULE: {{ .Rule }}
//         {{ .Code }}
//     {{ end }}
// {{ end }}
// {{ end }}
//
// {{ define "struct-convert" }}
// func (t {{ .Name }}Vgen) Convert() {{ .Name }} {
//     var res {{ .Name }}
//     {{ range .Fields }}
//         if t.{{ .Name }} != nil {
//             _{{ .Name }} := *t.{{ .Name }}
//             {{ .Field.ConvertCode }}
//         }
//     {{ end }}
//     return res
// }
// {{ end }}
//
// {{ define "prim-field-convert" }}
//     res.{{ .Name }} = _{{ .Name }}
// {{ end }}
//
// {{ define "type-field-convert" }}
//     res.{{ .Name }} = _{{ .Name }}.Convert()
// {{ end }}
//
// {{ define "list-field-convert-outer" }}
//     res.{{ .Name }}{{ .Path }} = make({{ .ConvertTyp }}, len(_{{ .Name }}))
//     for i{{ .Depth }}, _{{ .Name }} := range _{{ .Name }} {
//         {{ .Inner.ConvertCode }}
//     }
// {{ end }}
//
// {{ define "list-field-convert-inner" }}
//     res.{{ .Name }}{{ .Path }} = make({{ .ConvertTyp }}, len(_{{ .Name }}))
//     for i{{ .Depth }}, _{{ .Name }} := range _{{ .Name }} {
//         res.{{ .Name }}{{ .InnerPath }} = _{{ .Name }}{{ .InnerConvert }}
//     }
// {{ end }}
//
// {{ define "json-decoding" }}
// func {{ .Name }}FromJson(bytes []byte) ({{ .Name }}, map[string][]string) {
//     var v {{ .Name }}Vgen
//
//     err := json.Unmarshal(bytes, &v)
//     if err != nil {
//         return {{ .Name }}{}, err
//     }
//
//     r, err := v.ValidatedConvert()
//     if err != nil {
//         return {{ .Name }}{}, err
//     }
//
//     return r, nil
// }
// {{ end }}
// `
