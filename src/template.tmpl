{{ define "package" }}
// 
// THIS FILE IS GENERATED BY VGEN
// DO NOT EDIT
//

package {{ .Package }}
import (
    {{ range .Imports }}
        "{{ . }}"
    {{ end }}
)
{{ end }}

{{ define "struct-type" }}
type {{ .Name }}Vgen struct {
    {{- range .Fields }}
        {{ .Name }} *{{ .Typ }} {{ .Tags }}
    {{ end }}
}
{{ end }}

{{ define "struct-validation" }}
func (t {{ .Name }}Vgen) Validate() map[string][]string {
    errs := make(map[string][]string) 

    {{ range .Fields }}
        {{ $field := . }}
        if t.{{ .Name }} != nil {
        {{ if or .Include .Rules  }} 
            _{{ .Name }} := *t.{{ .Name }}
            {
            {{ range $i := iterate .Depth }}
                for i{{ $i }}, _{{ $field.Name }} := range _{{ $field.Name }} {
            {{ end }}

            path := fmt.Sprintf("{{ .Alias }}{{ range iterate .Depth }}[%d]{{ end }}"{{ range $i := iterate .Depth }}, i{{ $i }}{{ end }})

                {{ if .Include }}
                    struct_errs := _{{ .Name }}.Validate()
                    for nested_path, err_list := range struct_errs {
                        for _, err := range err_list {
                            errs[path + "." + nested_path] = append(errs[path + "." + nested_path], err) 
                        }    
                    }
                {{ end }}
                {{ if and .Include .Rules }}
                    _{{ .Name }} := _{{ .Name }}.Convert()
                {{ end }}

                {{ range .Rules }}
                    {{ call .Rule . }}
                {{ end }}

            {{ range $i := iterate .Depth }} } {{ end }}
            }
            {{ end }}

        } {{ if .Required }} else {
            errs["{{ .Alias }}"] = append(errs["{{ .Alias }}"], fmt.Sprintf("required"))
        } {{ end }}
    {{ end }}

    return errs
}
{{ end }}

{{ define "struct-convert" }}
func (t {{ .Name }}Vgen) Convert() {{ .Name }} {
    var res {{ .Name }}
    {{ range .Fields }}
        if t.{{ .Name }} != nil {
            _{{ .Name }} := *t.{{ .Name }}
            {{ if eq .Depth 0 }}
                res.{{ .Name }} = _{{ .Name }}{{ if .Include }}.Convert(){{ end }}
            {{ else if not .Include }}
                res.{{ .Name }} = _{{ .Name }}
            {{ else }}
                {{ $field := . }}
                {{ range $i := iterate .Depth }} 
                        res.{{ $field.Name }}{{ range $i := iterate $i }}[i{{ $i }}]{{ end }} = make({{ range $i := iterate (sub $field.Depth $i ) }}[]{{ end }}{{ $field.InnerTyp }}, len(_{{ $field.Name }}))
                    for i{{ $i }}, _{{ $field.Name }} := range _{{ $field.Name }} { 
                {{ end }}
                res.{{ .Name }}{{ range $i := iterate .Depth }}[i{{ $i }}]{{ end }} = _{{ .Name }}{{ if .Include }} .Convert() {{ end }}
                {{ range iterate .Depth }} } {{ end }}
            {{ end }}
        }
    {{ end }}
    return res
}
{{ end }}

{{ define "struct-validation-convert" }}
func (t {{ .Name }}Vgen) ValidatedConvert() ({{ .Name }}, *map[string][]string) {
    errs :=  t.Validate()
    if len(errs) > 0 {
        return {{ .Name }}{}, &errs
    }
    return t.Convert(), nil
}
{{ end }}


{{ define "json-decoding" }} 
func {{ .Name }}FromJson(bytes []byte) ({{ .Name }}, map[string][]string) {
    var v {{ .Name }}Vgen

    err := json.Unmarshal(bytes, &v)
    if err != nil {
        return {{ .Name }}{}, err
    }

    r, err := v.ValidatedConvert()
    if err != nil {
        return {{ .Name }}{}, err
    }

    return r, nil
}
{{ end }}
